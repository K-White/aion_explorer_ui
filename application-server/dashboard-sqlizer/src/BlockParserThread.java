import java.math.BigInteger;
import java.util.concurrent.CountDownLatch;

import org.json.JSONArray;
import org.json.JSONObject;

public class BlockParserThread extends Thread {

	DbHelper dbHelper;
	AionService[] aionService;
	Config config;
	int nodeNum;
	LastBlock lastBlock;
	BigInteger[] latestBlockDifficulty;

	BlockParserThread(){
		dbHelper = DbHelper.getDbHelper();
		config = Config.getConfig();
		nodeNum = config.getNodeNum();
		aionService = new AionService[nodeNum];
		lastBlock = LastBlock.getLastBlock();
		latestBlockDifficulty = new BigInteger[nodeNum];
				
		for(int i=0;i<nodeNum;i++) {
			aionService[i] = new AionService(config.getNodeAddress(i));
		}
	}

	public void run() {

		JSONObject blockDetails;

		while(true) {

			try {

				// populate active nodes & cache data
				populateActiveNodesAndCacheBlockData();
				System.out.println("\nActive node population done");

				// get healthiest node
				int node = getHealthiestNode();
				System.out.println("Healthy node found");

				// check if at least one node is up
				if(node!=-1) {

					// manage block reorganization
					manageBlockReorganization(aionService[node],(Long) aionService[node].getBlockNumber());
					System.out.println("Block reorganization done");

					long startBlock = dbHelper.getLastBlockNumber()+1;
					long endBlock = (Long) aionService[node].getBlockNumber();

					System.out.println("Block range begin "+startBlock+" "+endBlock);

					// update block and transaction details
					if(endBlock==startBlock) {
						getBlockDetailsAndSaveToDb(aionService[node],startBlock+"",true);
					}
					else if(startBlock<endBlock){
						// save blocks in multiples of 1000
						long counter = startBlock;
						while(counter<endBlock) {
							if((counter+998)<=endBlock) {
								getBlockDetailsAndSaveToDb(aionService[node],counter +"-"+(counter+998),false);
								counter = counter+998+1;
							}else {
								getBlockDetailsAndSaveToDb(aionService[node],counter +"-"+endBlock,true);
								break;
							}
							if(counter==endBlock) {
								getBlockDetailsAndSaveToDb(aionService[node],counter+"",true);
								break;
							}
						}
					}else {
						System.out.println("endblock smaller than start block "+startBlock+" "+endBlock);
					}
				}else {
					System.out.println("All Blockchain nodes are down");
				}


			}catch(Exception e) {
				e.printStackTrace();
			}

			// delay
			try {
				Thread.sleep(Long.parseLong(config.getDelayInPollingInMsec()));
			}catch(Exception e) {
				e.printStackTrace();
			}

		}

	}

	// dbCurrentBlock is latest block saved in db and aionCurrentBlock is latest block generated by blockchain
	// function will find the consistent block number and remove other invalid block numbers from db
	public void manageBlockReorganization(AionService aion, long aionCurrentBlock) {
		long dbCurrentBlock = dbHelper.getLastBlockNumber();
		long consistentBlock = 0;
		long initialDbBlock = dbCurrentBlock;

		// empty block chain
		if(dbCurrentBlock == -1)
			return;

		// if db's block number is lower than or equal to aion's block number
		if(dbCurrentBlock <= aionCurrentBlock) {
			while(true) {					
				String dbBlock = dbHelper.getHashFromBlockNumber(dbCurrentBlock);
				String aionBlock = aion.getBlockHashbyNumber(dbCurrentBlock);
				if(aionBlock!=null && dbBlock != null && aionBlock.equals(dbBlock))
					break;
				dbCurrentBlock--;
				if(dbCurrentBlock==-1)
					break;
			}
			consistentBlock = dbCurrentBlock;
		}

		// if db's block number is higher than aion's block number
		else {
			while(true) {
				String dbBlock = dbHelper.getHashFromBlockNumber(aionCurrentBlock);
				String aionBlock = aion.getBlockHashbyNumber(aionCurrentBlock);
				if(aionBlock!=null && dbBlock != null && aionBlock.equals(dbBlock))
					break;
				aionCurrentBlock--;
				if(aionCurrentBlock==-1)
					break;
			}
			consistentBlock = aionCurrentBlock;
		}

		// delete invalid blocks
		if(initialDbBlock != consistentBlock) {
			dbHelper.reorganizeBlocks(consistentBlock, aion);
		}

	}

	// get block details and save to db
	public void getBlockDetailsAndSaveToDb(AionService aion, String blockRange, boolean blockchainHead){
		System.out.println("blockchain range called "+blockRange);
		JSONObject blockDetails = aion.getBlockDetail(blockRange);
		// save to database
		System.out.println("Range fetched from blockchain saving to db "+blockRange);
		dbHelper.saveToBlockAndTransaction(blockDetails,aion,blockchainHead);
		System.out.println("Range saved to db\n");
	}

	// find node with highest total difficulty
	int getHealthiestNode() {
		int node = 0;
		BigInteger maxDifficulty = new BigInteger("0");
		
		for(int i=0;i<nodeNum;i++) {
			
			if(latestBlockDifficulty[i]!=null) {
				if(maxDifficulty.compareTo(latestBlockDifficulty[i]) == -1) {
					node = i;
					maxDifficulty = latestBlockDifficulty[i];
				}
			}
				
		}
		
		return node;
		
	}

	public void populateActiveNodesAndCacheBlockData() {
		try {
			// reset difficulty
			latestBlockDifficulty = new BigInteger[nodeNum];
			
			final CountDownLatch waitLatch = new CountDownLatch(nodeNum);
			for (int i = 0; i < nodeNum; i++) {
				BlockchainNode worker = new BlockchainNode(i,waitLatch);
				worker.start();
			}
			waitLatch.await();

		}catch(Exception e) {
			e.printStackTrace();
		}

	}

	class BlockchainNode extends Thread {

		int nodeIndex;
		CountDownLatch overLatch;

		BlockchainNode(int index,CountDownLatch waitLatch) {
			nodeIndex = index;
			overLatch = waitLatch;
		}

		public void run() {

			// check connection
			if(aionService[nodeIndex].isConnected()) {
				// get latest difficulty
				latestBlockDifficulty[nodeIndex] = aionService[nodeIndex].getLatestBlockDifficulty();
			}else {
				aionService[nodeIndex] = new AionService(aionService[nodeIndex].getNodeUrl());
			}
			overLatch.countDown();
		}
	}

}
